plugins {
    id 'maven-publish'
    id 'com.enonic.xp.app' version '3.4.0'
    id 'com.github.node-gradle.node' version '7.0.2'
    id 'no.item.xp.codegen' version '2.7.0'
}

app {
    name = "${appName}"
    displayName = "${appDisplayName}"
    vendorName = "${vendorName}"
    vendorUrl = "${vendorUrl}"
    systemVersion = "${xpVersion}"
}

dependencies {
    include "com.enonic.xp:lib-cluster:${xpVersion}"
    include "com.enonic.xp:lib-content:${xpVersion}"
    include "com.enonic.xp:lib-context:${xpVersion}"
    include "com.enonic.xp:lib-export:${xpVersion}"
    include "com.enonic.xp:lib-event:${xpVersion}"
    include "com.enonic.xp:lib-node:${xpVersion}"
    include "com.enonic.xp:lib-portal:${xpVersion}"
    include "com.enonic.xp:lib-project:${xpVersion}"
    include "com.enonic.xp:lib-task:${xpVersion}"
    include "com.enonic.xp:lib-repo:${xpVersion}"
    include "com.enonic.xp:lib-scheduler:${xpVersion}"
    include "com.enonic.lib:lib-http-client:3.2.2"
    include "com.enonic.lib:lib-thymeleaf:2.1.1"

    include "no.item:lib-xp-time:1.2.1"
}

repositories {
    mavenCentral()
    xp.enonicRepo()
    maven { url "https://repo.itemtest.no/releases" }
}

node {
    // Whether to download and install a specific Node.js version or not
    // If false, it will use the globally installed Node.js
    // If true, it will download node using above parameters
    // Note that npm is bundled with Node.js
    download = true

    // Version of node to download and install (only used if download is true)
    // It will be unpacked in the workDir
    version = '20.10.0'
}

apply from: "$projectDir/gradle/env.gradle"

tasks.register('dev', NpmTask) {
    args = [
        'run',
        'watch'
    ]
    dependsOn npmInstall, deploy, generateFrontendGqlTypes
    environment = [
        'FORCE_COLOR': 'true',
    ]
}

tasks.register('generateFrontendGqlTypes', Exec) {
    workingDir = file("${projectDir}/../frontend")
    commandLine 'npm', 'run', 'generate-gql-types'
}

tasks.register('npmCheck', NpmTask) {
    dependsOn npmInstall
    args = [
        'run',
        'check'
    ]
    environment = [
        'FORCE_COLOR': 'true',
    ]
}

tasks.register('npmBuild', NpmTask) {
    args = [
        'run',
        //'--silent',
        isProd() ? 'minify' : 'build'
    ]
    dependsOn npmInstall
    environment = [
        'FORCE_COLOR'          : 'true',
        'LOG_LEVEL_FROM_GRADLE': gradle.startParameter.logLevel.toString(),
        'NODE_ENV'             : nodeEnvironment()
    ]
    inputs.dir 'src/main/resources'
    outputs.dir 'build/resources/main'
}

// Copy generated types to frontend/src/types folder and prefix types with XP_
tasks.register('copyGeneratedTypes', Copy) {
    dependsOn generateTypeScript
    from("$projectDir/.xp-codegen")
    into("${projectDir}/../frontend/src/types/.xp-codegen")
    includeEmptyDirs = true

    // Rewrite exported declarations to be prefixed with XP_
    filteringCharset = 'UTF-8'
    filesMatching("**/*.d.ts") {
        filter { String line ->
            line
            // export type Button -> export type XP_Button
                .replaceAll(/\bexport\s+type\s+([A-Z]\w*)\b/, 'export type XP_$1')
            // export interface Button -> export interface XP_Button
                .replaceAll(/\bexport\s+interface\s+([A-Z]\w*)\b/, 'export interface XP_$1')
            // import("./button").Button; -> export interface XP_Button
                .replaceAll(/(import\([^)]+\)*\.)([A-Z]\w*);?\b/, '$1XP_$2')
        }
    }

}
tasks.named('generateTypeScript') {
    finalizedBy('copyGeneratedTypes')
}

check.dependsOn npmCheck
jar.dependsOn npmBuild

processResources {
    exclude '**/.gitkeep'
    exclude '**/*.json'
    exclude '**/*.sass'
    exclude '**/*.scss'
    exclude '**/*.ts'
    exclude '**/*.tsx'
}

processResources.dependsOn(generateTypeScript {
    singleQuote = true
})

